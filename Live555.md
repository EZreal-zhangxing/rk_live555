# 基于`Live555`网络推拉流技术的介绍

## Abstract

本文主要是对`live555`的开发网络推拉流代码流程进行记录，以及在进行推拉流开发时对遇到的一些问题进行记录。同时针对这些问题进行了一些源码的阅读以及分析。

本项目主要目标是通过`RK3588`来实现基于硬件编解码的网络推拉流服务。该服务分为两部分，一部分是网络推流，对应的另一部分是网络拉流。

推流主要流程是通过`RK3588`捕获图像后，交由硬件进行编码，并将编码后的数据通过`live555`进行广播或者单播到网络。可以使其他网络机器在较低延迟的情况下进行实时视频获取

拉流则流程与推流相反，通过单播或者多播的方式从网络获取数据报文，并通过硬件进行解码成对应的图像帧并显示。

## 1. 服务端

`Live555`服务端主要由分三部分：

1. 捕获视频/图片的模块
2. 视频编码模块
3. 码流发送模块

### 1.1 视频捕获模块

该模块主要目的是获取来自设备的图像数据，目前我使用了两种方式:分别是基于`Opencv`以及`v4l2`

#### 1.1.1 `Opencv`进行视频捕获

使用`Opencv`进行视频捕获只需要遵循以下流程即可

```
----------------	 --------		 --------     --------	   -----------------
| VideoCapture | --> | open | -->    | read | --> | data | --> | do somethings |
----------------	 --------		 --------	  --------	   -----------------
										^					 			|
										|					 			|
										|					 			V
										--------------------------------- 
```

1. 实例化`VideoCapture`
2. 调用`open`打开驱动`/dev/video*`
3.  从驱动里读取数据
4. 消费数据
5. 重复第3步

该流程很简单，是`opencv`读取数据的标准流程，此处不做过多介绍

#### 1.1.2 `v4l2`视频读取

`v4l2`是`linux`内核中关于视频设备驱动的框架，主要通过`ioctl(I/O control)`与驱动进行交互。
`ioctl(int fd,unsigned long int cmd，param,...)`函数参数主要由三个部分组成：第一部分为文件句柄，通过这个唯一句柄识别驱动，第二部分为交互指令，该指令通知设备进行什么操作，第三部分则是传入或者传出参数
`sys/ioctl.h`主要通过第二个参数的协议来与IO设备进行交互指令发送，已使驱动完成特定功能，在用户空间通过调用`ioctl`,会进入内核调用`sys_ioctl`,然后内核通过指令发送给驱动进行特定的操作。

因此使用`v4l2`对摄像头驱动或者`HDMI`输入驱动都可以，通过命令交互的方式拿到对应的数据。
主要流程如下：

1. `open`函数打开设备驱动获得文件句柄`fd`
2. `VIDIOC_S_FMT`设置采集格式，输入是`v4l2_format`格式的数据，对于设备采集的数据类型可以通过:`v4l2-ctl -d /dev/video* -V -D `进行查询驱动所支持的数据格式。对于可捕获的格式主要分两种：`V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE`以及`V4L2_BUF_TYPE_VIDEO_CAPTURE`，这两种类别在后面分别对应不同的处理方法，但大致是相同的。主要区别在于`multiplane`相比较与`CAPTURE`会返回多个`plane`，需要迭代去处理,而`CAPTURE`可以直接获取一帧图像。`RK3588`的`HDMI`输入只支持`multiplane`，因此下面以`multiplane`进行介绍
3. 在第2步设置采集格式后，可以通过`VIDIOC_G_FMT`进行查询采集格式是否设置正确，该指令输入和输出均是`v4l2_format`。
4. 申请缓冲队列，`VIDIOC_REQBUFS`通过该指令可以在内核开启对应个数的缓冲区，设备驱动会将数据写入该部分，利用程序对这块进行读写既可以获得视频数据。这里memory有多种方式，采用最多的是`V4L2_MEMORY_MMAP`内存映射方式，即将内核空间的区域映射到用户空间。同时还注意`V4L2_MEMORY_DMABUF`(有待补充)
5. 申请缓存之后，同时要注意，我们的设备捕获的是`multiplane`的模式，一帧数据会返回多个`plane`(具体有多少个`plane`在第3步进行采集格式查询的时候会返回)，因此我们需要创建一块用户空间的内存区域，其中包含了和缓存队列元素个数一致的用户内存区域，用来对缓存队列进行内存映射。因为是`multiplane`模式，所以我们定义一个`v4l2_plane`的数组，同时也定义了一个和`v4l2_plane`一一对应的用户空间地址`mmpaddr`,见：`struct image_buffer_with_plane`，并将`plane`信息与`v4l2_buffer`进行绑定,然后使用`VIDIOC_QUERYBUF`查询缓存信息，然后使用`mmap`函数根据缓存查询出来的`plane`大小和偏移，**逐一映射到用户空间**。缓存队列的长度同时也决定了`struct image_buffer_with_plane`的数组长度。
6. 在第5步映射完毕后，需要将查询到的`plane`进行入队,`VIDIOC_QBUF`指令，这样驱动在获取到数据后，会将数据写入该队列，等待消费，在我们将缓存出队消费掉后进行压队。以达到循环使用的过程

```
				                     data
				                      |
				   ---------------------------------------
				   |                                     |
				  pop                                 	push
				   ^                                     |
				   |                                     V
				-------    -------    -------         -------
				| ele | -- | ele | -- | ... |         | ele |
				-------    -------    -------         -------  

```
7. `VIDIOC_STREAMON` 开始进行数据获取
8. 使用`VIDIOC_DQBUF`指令进行出队操作，主要输入输出也是`v4l2_buffer`,出队后，根据`v4l2_buffer`中的`index`确定是属于队列的第几个元素，与第5步中申请的`image_buffer_with_plane`索引一致。**遍历`plane`，逐个`plane`进行拷出**
9. 出队后的数据，再次放回队列`VIDIOC_QBUF`
10. `VIDIOC_STREAMOFF`关闭数据获取
11. 取消映射`munmap`
12. `close`设备句柄


```   
                                                                                
                      ---------------------                                     
                      |    v4l2_format    |                                     
                      ---------------------                                     
                        |            ^                                          
                        |            |                                          
                        |            |                                          
                        V            |                                          
--------     ----------------     ----------------     -------------------     --------------------
| open | --> |  set_format  | --> |  get_format  | --> | request_buffer  | --> |   query_buffer   |
--------     ----------------     ----------------     -------------------     --------------------
                                                                                          |
                                                                                          V
                                                                                  ----------------           --------------------      ---------------
                                                                                  |   planes[n]  |  -mmap->  |   mmpaddress[n]  |  --> |  read data  |  
                                                                                  ----------------           --------------------      ---------------
                                                                                  |   planes[n]  |  -mmap->  |   mmpaddress[n]  |  --> |  read data  |  
                                                                 -------------->  |---------------           |-------------------      ---------------
                                                                 |                |   planes[n]  |  -mmap->  |   mmpaddress[n]  |  --> |  read data  |  
                                                                 |                |---------------           |-------------------      ---------------
                                                                 |                |   planes[n]  |  -mmap->  |   mmpaddress[n]  |  --> |  read data  |  
                                                                 |                ----------------           --------------------      ---------------
                                                                 |                        |          
                                                        ----------------                  V
                                                        | pop_out_data |          ------------------
                                                        ----------------          |  push_in_queue |
                                                                 |                ------------------
                                                                 |                        |
                                                                 |                  ---------------
                                                                 |                  |  stream on  |
                                                                 |                  ---------------
                                                                 |                        |
                                                                 |                        |
                                                                 --------------------------
                                                                                          |
                                                                                    ----------------
                                                                                    |  stream off  |
                                                                                    ----------------
                                                                                          |
                                                                                      ---------
                                                                                      | close |
                                                                                      ---------


```

### 1.2 视频编码模块


# Reference

1. [linux 内核 - ioctl讲解](https://zhuanlan.zhihu.com/p/478259733)
2. [一文分析Linux v4l2框架](https://zhuanlan.zhihu.com/p/613018868)


